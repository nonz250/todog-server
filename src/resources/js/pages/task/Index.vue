<template>
    <div>
        <ul class="horizontal-list">
            <li class="task-list" v-for="(list, index) in lists">
                <task-list :task-list="list" @clickAddTask="clickAddTask"/>
            </li>
            <li class="task-list">
                <v-btn text outlined block class="add-list-container" color="primary"
                       @click="isDisplayInputName = !isDisplayInputName">
                    <span v-show="!isDisplayInputName">
                        <v-icon>mdi-plus-circle-outline</v-icon>
                        リストを追加する
                    </span>
                    <span v-show="isDisplayInputName">
                        <v-icon>mdi-minus-circle-outline</v-icon>
                        キャンセル
                    </span>
                </v-btn>
                <v-text-field v-show="isDisplayInputName" v-model="name" placeholder="タスクリスト名"/>
                <v-btn v-show="isDisplayInputName"
                       color="primary"
                       text
                       outlined
                       class="float-right"
                       @click="clickAddList"
                >
                    <v-icon>mdi-plus-circle-outline</v-icon>
                    追加
                </v-btn>
            </li>
        </ul>
    </div>
</template>

<script>
    import mixin from "../../mixins/mixin";

    export default {
        name: "Index",
        mixins: [mixin],
        data() {
            return {
                isDisplayInputName: false,
                name: '',
                lists: [
                    {id: 1, name: 'タスクリストの設定項目'},
                    {id: 1, name: 'タスクリストの設定項目'},
                    {id: 1, name: 'タスクリストの設定項目'},
                ],
            }
        },
        methods: {
            click() {
                const loader = this.$store.getters['loader/loader'];
                this.$store.dispatch('loader/setLoader', !loader);
            },
            async clickAddList() {
                await this.$store.dispatch('loader/setLoader', true);
                const params = new FormData();
                params.append('name', this.name);
                const res = await this.api('post', '/api/task_list', params);
                if (res.status === 200) {
                    this.lists.push({
                        id: res.data.id,
                        name: res.data.name,
                    });
                } else if (res.status === 422) {
                    await this.$store.dispatch('snackbar/setSnackbar', true);
                    await this.$store.dispatch('snackbar/setText', this.getMessages(res.data.errors));
                    await this.$store.dispatch('snackbar/setColor', 'error');
                } else {
                    await this.$store.dispatch('snackbar/setSnackbar', true);
                    await this.$store.dispatch('snackbar/setText', 'サーバーでエラーが発生しました。');
                    await this.$store.dispatch('snackbar/setColor', 'error');
                }
                await this.$store.dispatch('loader/setLoader', false);
            },
            clickAddTask(task) {
                const params = new FormData();
                params.append('name', task.name);
                const res = this.api('post', '/api/task', params);
                if (res.status === 200) {
                    // this.variant = 'primary'
                    // this.snackbarText = this.getMessages(res.data.messages)
                    // this.snackbar = true
                    // this.users.unshift(res.data.users)
                    // alert(this.getMessages(res.data.messages))
                } else if (res.status === 422) {
                    // this.variant = 'error'
                    // this.snackbarText = this.getMessages(res.data.errors)
                    // this.snackbar = true
                    // alert(this.getMessages(res.data.errors))
                } else {
                    // this.variant = 'error'
                    // this.snackbarText = this.getMessages([res.data.message])
                    // this.snackbar = true
                    // alert(this.getMessages([res.data.message]))
                }

                // this.tasks.push(task);
            }
        }
    }
</script>

<style scoped>
    .horizontal-list {
        overflow-x: auto;
        white-space: nowrap;
        -webkit-overflow-scrolling: touch;
        margin: 0;
        padding: 0;
    }

    .task-list {
        display: inline-block;
        vertical-align: top;
        height: 100vh;
        margin: 0;
        padding: 1rem;
    }

    .card-max-height {
        /* TODO: ここのカード高は使ってみて決める */
        /* height: 80vh; */
    }

    .add-list-container {
        border: dashed 2px #000000;
    }

    @media screen and (min-width: 375px) and (max-width: 850px) {
        .task-list {
            width: 90%;
        }
    }

    @media screen and (min-width: 851px) and (max-width: 920px) {
        .task-list {
            width: 60%;
        }
    }

    @media screen and (min-width: 921px) {
        .task-list {
            width: 40%;
        }
    }
</style>
